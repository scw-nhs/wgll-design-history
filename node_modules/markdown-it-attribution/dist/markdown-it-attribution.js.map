{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"markdown-it-attribution.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = function attributionPlugin (md, options) {\n  /**\n   * A regular expression matching common URL patterns.\n   *\n   * @see {@link https://mathiasbynens.be/demo/url-regex}\n   *\n   * @type {RegExp}\n   */\n  var REGEX_URL = /https?:\\/\\/[^\\s/$.?#()].[^\\s()]*/i;\n\n  /**\n   * An enumeration of token types.\n   *\n   * @type {Object<string,string>}\n   */\n  var TokenType = {\n    BLOCKQUOTE_OPEN: 'blockquote_open',\n    BLOCKQUOTE_CLOSE: 'blockquote_close'\n  };\n\n  /**\n   * Default options of the parser plugin.\n   *\n   * @type {Object}\n   */\n  var Defaults = {\n    classNameContainer: 'c-blockquote',\n    classNameAttribution: 'c-blockquote__attribution',\n    marker: 'â€”', // EM dash\n    removeMarker: true\n  };\n\n  /**\n   * Copy the values of all enumerable own properties from a source object to a\n   * target object.\n   *\n   * @type {Function}\n   */\n  var assign = md.utils.assign;\n\n  /**\n   * Prepare the plugin options and merge user options with the defauls.\n   *\n   * @type {Object}\n   */\n  options = assign({}, Defaults, options);\n\n  /**\n   * Determine whether the given value is an integer.\n   *\n   * @param {*} value The value to inspect.\n   * @return {Boolean}\n   */\n  function isInteger (value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n  }\n\n  /**\n   * Determine whether a given string is empty.\n   *\n   * @param {string} str The string to inspect.\n   * @return {Boolean}\n   */\n  function isEmpty (str) {\n    return !str || (str.length === 0) || (str.trim().length === 0);\n  }\n\n  /**\n   * Determine whether the given property exists.\n   *\n   * @param {Object} obj The object to inspect.\n   * @param {string} prop The property to test for.\n   * @return {Boolean}\n   */\n  function has (obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  /**\n   * Extract an url from the given string.\n   *\n   * @param {string} str The string to extract an url from.\n   * @return {string}\n   */\n  function extractUrl (str) {\n    var matches = str.match(REGEX_URL);\n    return matches !== null\n      ? matches.shift()\n      : null;\n  }\n\n  /**\n   * Determines whether a string begins with the characters of a another string.\n   *\n   * @param {string} str The string to inspect.\n   * @param {string} needle The string to search for.\n   * @return {Boolean}\n   */\n  function startsWith (str, needle) {\n    return str.slice(0, needle.length) === needle;\n  }\n\n  /**\n   * Remove whitespace from the beginning of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimStart (str) {\n    return str.replace(/^\\s+/, '');\n  }\n\n  /**\n   * Remove whitespace from the end of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimEnd (str) {\n    return str.replace(/\\s+$/, '');\n  }\n\n  /**\n   * Insert multiple items at the given index position.\n   *\n   * @param {Array} array The array to add items to.\n   * @param {Object[]} items One or multiple items to add.\n   * @param {Number} position The index position at which to add the items.\n   */\n  function insertAt (array, items, position) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      array.splice(position + i, 0, items[i]);\n    }\n  }\n\n  /**\n   * Remove all items between the given indices.\n   *\n   * @param {Array} array The array to remove items from.\n   * @param {Number} [from=0] The index to start from.\n   * @param {Number} [to=array.length-1] The index at which to stop deletion.\n   * @return {Number}\n   */\n  function remove (array, from, to) {\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : array.length - 1;\n\n    var amount = to - from;\n    var items = array.splice(from, amount);\n\n    return items.length;\n  }\n\n  /**\n   * Determine whether the given object has equal property values.\n   *\n   * @param {Object} obj The object to inspect.\n   * @param {Object} props The collection of property values to test.\n   * @return {Boolean}\n   */\n  function matches (obj, props) {\n    for (var prop in props) {\n      if (has(props, prop) && (props[prop] !== obj[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Find the index of the first token that has equal property values.\n   *\n   * @param {MarkdownIt.Token[]} tokens A token stream to search within.\n   * @param {Object<string,*>} props A collection of key<->value pairs to match against.\n   * @param {Number} [position=0] The start index to start searching from.\n   * @return {Number}\n   */\n  function findToken (tokens, props, position) {\n    position = isInteger(position) ? position : 0;\n\n    for (var i = position, l = tokens.length; i < l; i++) {\n      if (matches(tokens[i], props)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Find the index position of a given marker in a string.\n   *\n   * NOTE: An attribution marker either has to be the first character of a\n   * string or it has to be immediately following a soft break/line break.\n   *\n   * @param {string} str The string to search within.\n   * @param {string} marker The marker to search for.\n   * @return {Number}\n   */\n  function findMarker (str, marker) {\n    // Return early if the paragraph starts with the marker.\n    if (startsWith(str, marker)) {\n      return 0;\n    }\n\n    // Search for the marker following a soft break.\n    var length = marker.length;\n    var position = str.indexOf('\\n' + marker, length + 1);\n\n    return (position > length) ? position + 1 : -1;\n  }\n\n  /**\n   * Find a attribution line within the given range.\n   *\n   * @param {MarkdownIt.Token[]} tokens The token stream to search.\n   * @param {string} marker The character code of the attribution marker.\n   * @param {Number} [level=0] The level of the block quote.\n   * @param {Number} [from=0] The index position to start searching from.\n   * @param {Number} [to=tokens.length-1] The upper boundary to stop searching.\n   * @return {Number}\n   */\n  function findAttribution (tokens, marker, level, from, to) {\n    level = isInteger(level) ? level : 0;\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : tokens.length;\n\n    for (var i = from; i < to; i++) {\n      var token = tokens[i];\n      var content = token.content;\n\n      if ((token.type !== 'inline') || (token.level !== level + 2) || (content.length === 0)) {\n        continue;\n      }\n\n      var position = findMarker(content, marker);\n\n      if (position !== -1) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Attribution Rule\n   *\n   * Improve the generated HTML markup for block quotes with proper attribution\n   * syntax.\n   *\n   * @param {MarkdownIt.StateCore} state The current state of the parser.\n   * @return {void}\n   */\n  function rule (state) {\n    var tokens = state.tokens;\n\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      // Find the opening tag of the next blockquote.\n      var start = findToken(tokens, { type: TokenType.BLOCKQUOTE_OPEN }, i);\n\n      if (start === -1) {\n        continue;\n      }\n\n      // Find the closing tag of the current block quote.\n      var level = tokens[start].level;\n      var end = findToken(tokens, { type: TokenType.BLOCKQUOTE_CLOSE, level: level }, start + 1);\n\n      /* istanbul ignore if */\n      if (end === -1) {\n        continue;\n      }\n\n      // Find the attribution line of the current block quote.\n      var position = findAttribution(tokens, options.marker, level, start + 1, end);\n\n      if (position === -1) {\n        continue;\n      }\n\n      // Increase the level of each block quote token as it will be wrapped in a\n      // container element.\n      for (var j = start; j <= end; j++) {\n        tokens[j].level++;\n      }\n\n      // Remove the attribution line from the rest of the paragraph.\n      var token = tokens[position];\n      var source = token.content;\n      var index = findMarker(source, options.marker);\n\n      var content = (index > 0) ? trimEnd(source.slice(0, index)) : null;\n      var attribution = (index > 0) ? source.slice(index) : source;\n\n      token.content = content;\n\n      // Remove the paragraph tokens from the stream, if no content is left.\n      if (isEmpty(content)) {\n        end -= remove(tokens, position - 1, position + 2);\n      }\n\n      // Use any url found in the attribution line as the cite attribute.\n      var blockquoteOpen = tokens[start];\n      var url = extractUrl(attribution);\n\n      if (!isEmpty(url)) {\n        blockquoteOpen.attrSet('cite', url);\n      }\n\n      // Create new tokens for the attribution line.\n      var captionOpen = new state.Token('blockquote_attribution_open', 'figcaption', 1);\n      captionOpen.block = true;\n      captionOpen.level = level + 1;\n\n      var caption = new state.Token('inline', '', 0);\n      caption.children = [];\n      caption.level = level + 2;\n      caption.content = options.removeMarker\n        ? trimStart(attribution.slice(options.marker.length))\n        : attribution;\n\n      var captionClose = new state.Token('blockquote_attribution_close', 'figcaption', -1);\n      captionClose.block = true;\n      captionClose.level = level + 1;\n\n      if (!isEmpty(options.classNameAttribution)) {\n        captionOpen.attrSet('class', options.classNameAttribution);\n      }\n\n      insertAt(tokens, [captionOpen, caption, captionClose], end + 1);\n\n      // Wrap block quote and attribution in a figure element.\n      var figureOpen = new state.Token('blockquote_container_open', 'figure', 1);\n      figureOpen.block = true;\n      figureOpen.level = level;\n\n      var figureClose = new state.Token('blockquote_container_close', 'figure', -1);\n      figureClose.block = true;\n      figureClose.level = level;\n\n      if (!isEmpty(options.classNameContainer)) {\n        figureOpen.attrSet('class', options.classNameContainer);\n      }\n\n      insertAt(tokens, [figureClose], end + 4);\n      insertAt(tokens, [figureOpen], start);\n\n      // Skip the generated block quote tokens in the stream.\n      i = end + 5;\n\n      // Update the length of the token stream.\n      l = l + 4;\n    }\n  }\n\n  md.core.ruler.after('block', 'attribution', rule);\n};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXR0cmlidXRpb25QbHVnaW4gKG1kLCBvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGluZyBjb21tb24gVVJMIHBhdHRlcm5zLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXh9XG4gICAqXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICB2YXIgUkVHRVhfVVJMID0gL2h0dHBzPzpcXC9cXC9bXlxccy8kLj8jKCldLlteXFxzKCldKi9pO1xuXG4gIC8qKlxuICAgKiBBbiBlbnVtZXJhdGlvbiBvZiB0b2tlbiB0eXBlcy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAgICovXG4gIHZhciBUb2tlblR5cGUgPSB7XG4gICAgQkxPQ0tRVU9URV9PUEVOOiAnYmxvY2txdW90ZV9vcGVuJyxcbiAgICBCTE9DS1FVT1RFX0NMT1NFOiAnYmxvY2txdW90ZV9jbG9zZSdcbiAgfTtcblxuICAvKipcbiAgICogRGVmYXVsdCBvcHRpb25zIG9mIHRoZSBwYXJzZXIgcGx1Z2luLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIERlZmF1bHRzID0ge1xuICAgIGNsYXNzTmFtZUNvbnRhaW5lcjogJ2MtYmxvY2txdW90ZScsXG4gICAgY2xhc3NOYW1lQXR0cmlidXRpb246ICdjLWJsb2NrcXVvdGVfX2F0dHJpYnV0aW9uJyxcbiAgICBtYXJrZXI6ICfigJQnLCAvLyBFTSBkYXNoXG4gICAgcmVtb3ZlTWFya2VyOiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIENvcHkgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhXG4gICAqIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHZhciBhc3NpZ24gPSBtZC51dGlscy5hc3NpZ247XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIHBsdWdpbiBvcHRpb25zIGFuZCBtZXJnZSB1c2VyIG9wdGlvbnMgd2l0aCB0aGUgZGVmYXVscy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIG9wdGlvbnMgPSBhc3NpZ24oe30sIERlZmF1bHRzLCBvcHRpb25zKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0ludGVnZXIgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHN0cmluZyBpcyBlbXB0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0VtcHR5IChzdHIpIHtcbiAgICByZXR1cm4gIXN0ciB8fCAoc3RyLmxlbmd0aCA9PT0gMCkgfHwgKHN0ci50cmltKCkubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gcHJvcGVydHkgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHRlc3QgZm9yLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzIChvYmosIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBhbiB1cmwgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gZXh0cmFjdCBhbiB1cmwgZnJvbS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0cmFjdFVybCAoc3RyKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2goUkVHRVhfVVJMKTtcbiAgICByZXR1cm4gbWF0Y2hlcyAhPT0gbnVsbFxuICAgICAgPyBtYXRjaGVzLnNoaWZ0KClcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgYmVnaW5zIHdpdGggdGhlIGNoYXJhY3RlcnMgb2YgYSBhbm90aGVyIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnRzV2l0aCAoc3RyLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIG5lZWRsZS5sZW5ndGgpID09PSBuZWVkbGU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbVN0YXJ0IChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1FbmQgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBnaXZlbiBpbmRleCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGFkZCBpdGVtcyB0by5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXMgT25lIG9yIG11bHRpcGxlIGl0ZW1zIHRvIGFkZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBpbmRleCBwb3NpdGlvbiBhdCB3aGljaCB0byBhZGQgdGhlIGl0ZW1zLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zZXJ0QXQgKGFycmF5LCBpdGVtcywgcG9zaXRpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYXJyYXkuc3BsaWNlKHBvc2l0aW9uICsgaSwgMCwgaXRlbXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW1vdmUgaXRlbXMgZnJvbS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tPTBdIFRoZSBpbmRleCB0byBzdGFydCBmcm9tLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RvPWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RvcCBkZWxldGlvbi5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlIChhcnJheSwgZnJvbSwgdG8pIHtcbiAgICBmcm9tID0gaXNJbnRlZ2VyKGZyb20pID8gZnJvbSA6IDA7XG4gICAgdG8gPSBpc0ludGVnZXIodG8pID8gdG8gOiBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGFtb3VudCA9IHRvIC0gZnJvbTtcbiAgICB2YXIgaXRlbXMgPSBhcnJheS5zcGxpY2UoZnJvbSwgYW1vdW50KTtcblxuICAgIHJldHVybiBpdGVtcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1YWwgcHJvcGVydHkgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBjb2xsZWN0aW9uIG9mIHByb3BlcnR5IHZhbHVlcyB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hlcyAob2JqLCBwcm9wcykge1xuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChoYXMocHJvcHMsIHByb3ApICYmIChwcm9wc1twcm9wXSAhPT0gb2JqW3Byb3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHRva2VuIHRoYXQgaGFzIGVxdWFsIHByb3BlcnR5IHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlRva2VuW119IHRva2VucyBBIHRva2VuIHN0cmVhbSB0byBzZWFyY2ggd2l0aGluLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsKj59IHByb3BzIEEgY29sbGVjdGlvbiBvZiBrZXk8LT52YWx1ZSBwYWlycyB0byBtYXRjaCBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBzdGFydCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZFRva2VuICh0b2tlbnMsIHByb3BzLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gaXNJbnRlZ2VyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogMDtcblxuICAgIGZvciAodmFyIGkgPSBwb3NpdGlvbiwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChtYXRjaGVzKHRva2Vuc1tpXSwgcHJvcHMpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGdpdmVuIG1hcmtlciBpbiBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogQW4gYXR0cmlidXRpb24gbWFya2VyIGVpdGhlciBoYXMgdG8gYmUgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhXG4gICAqIHN0cmluZyBvciBpdCBoYXMgdG8gYmUgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGEgc29mdCBicmVhay9saW5lIGJyZWFrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VhcmNoIHdpdGhpbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciBUaGUgbWFya2VyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRNYXJrZXIgKHN0ciwgbWFya2VyKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHRoZSBwYXJhZ3JhcGggc3RhcnRzIHdpdGggdGhlIG1hcmtlci5cbiAgICBpZiAoc3RhcnRzV2l0aChzdHIsIG1hcmtlcikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG1hcmtlciBmb2xsb3dpbmcgYSBzb2Z0IGJyZWFrLlxuICAgIHZhciBsZW5ndGggPSBtYXJrZXIubGVuZ3RoO1xuICAgIHZhciBwb3NpdGlvbiA9IHN0ci5pbmRleE9mKCdcXG4nICsgbWFya2VyLCBsZW5ndGggKyAxKTtcblxuICAgIHJldHVybiAocG9zaXRpb24gPiBsZW5ndGgpID8gcG9zaXRpb24gKyAxIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIGF0dHJpYnV0aW9uIGxpbmUgd2l0aGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlRva2VuW119IHRva2VucyBUaGUgdG9rZW4gc3RyZWFtIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIGF0dHJpYnV0aW9uIG1hcmtlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbD0wXSBUaGUgbGV2ZWwgb2YgdGhlIGJsb2NrIHF1b3RlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb209MF0gVGhlIGluZGV4IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RvPXRva2Vucy5sZW5ndGgtMV0gVGhlIHVwcGVyIGJvdW5kYXJ5IHRvIHN0b3Agc2VhcmNoaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQXR0cmlidXRpb24gKHRva2VucywgbWFya2VyLCBsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICBsZXZlbCA9IGlzSW50ZWdlcihsZXZlbCkgPyBsZXZlbCA6IDA7XG4gICAgZnJvbSA9IGlzSW50ZWdlcihmcm9tKSA/IGZyb20gOiAwO1xuICAgIHRvID0gaXNJbnRlZ2VyKHRvKSA/IHRvIDogdG9rZW5zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuXG4gICAgICBpZiAoKHRva2VuLnR5cGUgIT09ICdpbmxpbmUnKSB8fCAodG9rZW4ubGV2ZWwgIT09IGxldmVsICsgMikgfHwgKGNvbnRlbnQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gZmluZE1hcmtlcihjb250ZW50LCBtYXJrZXIpO1xuXG4gICAgICBpZiAocG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRyaWJ1dGlvbiBSdWxlXG4gICAqXG4gICAqIEltcHJvdmUgdGhlIGdlbmVyYXRlZCBIVE1MIG1hcmt1cCBmb3IgYmxvY2sgcXVvdGVzIHdpdGggcHJvcGVyIGF0dHJpYnV0aW9uXG4gICAqIHN5bnRheC5cbiAgICpcbiAgICogQHBhcmFtIHtNYXJrZG93bkl0LlN0YXRlQ29yZX0gc3RhdGUgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHBhcnNlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bGUgKHN0YXRlKSB7XG4gICAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gRmluZCB0aGUgb3BlbmluZyB0YWcgb2YgdGhlIG5leHQgYmxvY2txdW90ZS5cbiAgICAgIHZhciBzdGFydCA9IGZpbmRUb2tlbih0b2tlbnMsIHsgdHlwZTogVG9rZW5UeXBlLkJMT0NLUVVPVEVfT1BFTiB9LCBpKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgY2xvc2luZyB0YWcgb2YgdGhlIGN1cnJlbnQgYmxvY2sgcXVvdGUuXG4gICAgICB2YXIgbGV2ZWwgPSB0b2tlbnNbc3RhcnRdLmxldmVsO1xuICAgICAgdmFyIGVuZCA9IGZpbmRUb2tlbih0b2tlbnMsIHsgdHlwZTogVG9rZW5UeXBlLkJMT0NLUVVPVEVfQ0xPU0UsIGxldmVsOiBsZXZlbCB9LCBzdGFydCArIDEpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIG9mIHRoZSBjdXJyZW50IGJsb2NrIHF1b3RlLlxuICAgICAgdmFyIHBvc2l0aW9uID0gZmluZEF0dHJpYnV0aW9uKHRva2Vucywgb3B0aW9ucy5tYXJrZXIsIGxldmVsLCBzdGFydCArIDEsIGVuZCk7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEluY3JlYXNlIHRoZSBsZXZlbCBvZiBlYWNoIGJsb2NrIHF1b3RlIHRva2VuIGFzIGl0IHdpbGwgYmUgd3JhcHBlZCBpbiBhXG4gICAgICAvLyBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICB0b2tlbnNbal0ubGV2ZWwrKztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIGZyb20gdGhlIHJlc3Qgb2YgdGhlIHBhcmFncmFwaC5cbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1twb3NpdGlvbl07XG4gICAgICB2YXIgc291cmNlID0gdG9rZW4uY29udGVudDtcbiAgICAgIHZhciBpbmRleCA9IGZpbmRNYXJrZXIoc291cmNlLCBvcHRpb25zLm1hcmtlcik7XG5cbiAgICAgIHZhciBjb250ZW50ID0gKGluZGV4ID4gMCkgPyB0cmltRW5kKHNvdXJjZS5zbGljZSgwLCBpbmRleCkpIDogbnVsbDtcbiAgICAgIHZhciBhdHRyaWJ1dGlvbiA9IChpbmRleCA+IDApID8gc291cmNlLnNsaWNlKGluZGV4KSA6IHNvdXJjZTtcblxuICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcGFyYWdyYXBoIHRva2VucyBmcm9tIHRoZSBzdHJlYW0sIGlmIG5vIGNvbnRlbnQgaXMgbGVmdC5cbiAgICAgIGlmIChpc0VtcHR5KGNvbnRlbnQpKSB7XG4gICAgICAgIGVuZCAtPSByZW1vdmUodG9rZW5zLCBwb3NpdGlvbiAtIDEsIHBvc2l0aW9uICsgMik7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBhbnkgdXJsIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGlvbiBsaW5lIGFzIHRoZSBjaXRlIGF0dHJpYnV0ZS5cbiAgICAgIHZhciBibG9ja3F1b3RlT3BlbiA9IHRva2Vuc1tzdGFydF07XG4gICAgICB2YXIgdXJsID0gZXh0cmFjdFVybChhdHRyaWJ1dGlvbik7XG5cbiAgICAgIGlmICghaXNFbXB0eSh1cmwpKSB7XG4gICAgICAgIGJsb2NrcXVvdGVPcGVuLmF0dHJTZXQoJ2NpdGUnLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IHRva2VucyBmb3IgdGhlIGF0dHJpYnV0aW9uIGxpbmUuXG4gICAgICB2YXIgY2FwdGlvbk9wZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ2Jsb2NrcXVvdGVfYXR0cmlidXRpb25fb3BlbicsICdmaWdjYXB0aW9uJywgMSk7XG4gICAgICBjYXB0aW9uT3Blbi5ibG9jayA9IHRydWU7XG4gICAgICBjYXB0aW9uT3Blbi5sZXZlbCA9IGxldmVsICsgMTtcblxuICAgICAgdmFyIGNhcHRpb24gPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICAgIGNhcHRpb24uY2hpbGRyZW4gPSBbXTtcbiAgICAgIGNhcHRpb24ubGV2ZWwgPSBsZXZlbCArIDI7XG4gICAgICBjYXB0aW9uLmNvbnRlbnQgPSBvcHRpb25zLnJlbW92ZU1hcmtlclxuICAgICAgICA/IHRyaW1TdGFydChhdHRyaWJ1dGlvbi5zbGljZShvcHRpb25zLm1hcmtlci5sZW5ndGgpKVxuICAgICAgICA6IGF0dHJpYnV0aW9uO1xuXG4gICAgICB2YXIgY2FwdGlvbkNsb3NlID0gbmV3IHN0YXRlLlRva2VuKCdibG9ja3F1b3RlX2F0dHJpYnV0aW9uX2Nsb3NlJywgJ2ZpZ2NhcHRpb24nLCAtMSk7XG4gICAgICBjYXB0aW9uQ2xvc2UuYmxvY2sgPSB0cnVlO1xuICAgICAgY2FwdGlvbkNsb3NlLmxldmVsID0gbGV2ZWwgKyAxO1xuXG4gICAgICBpZiAoIWlzRW1wdHkob3B0aW9ucy5jbGFzc05hbWVBdHRyaWJ1dGlvbikpIHtcbiAgICAgICAgY2FwdGlvbk9wZW4uYXR0clNldCgnY2xhc3MnLCBvcHRpb25zLmNsYXNzTmFtZUF0dHJpYnV0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0QXQodG9rZW5zLCBbY2FwdGlvbk9wZW4sIGNhcHRpb24sIGNhcHRpb25DbG9zZV0sIGVuZCArIDEpO1xuXG4gICAgICAvLyBXcmFwIGJsb2NrIHF1b3RlIGFuZCBhdHRyaWJ1dGlvbiBpbiBhIGZpZ3VyZSBlbGVtZW50LlxuICAgICAgdmFyIGZpZ3VyZU9wZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ2Jsb2NrcXVvdGVfY29udGFpbmVyX29wZW4nLCAnZmlndXJlJywgMSk7XG4gICAgICBmaWd1cmVPcGVuLmJsb2NrID0gdHJ1ZTtcbiAgICAgIGZpZ3VyZU9wZW4ubGV2ZWwgPSBsZXZlbDtcblxuICAgICAgdmFyIGZpZ3VyZUNsb3NlID0gbmV3IHN0YXRlLlRva2VuKCdibG9ja3F1b3RlX2NvbnRhaW5lcl9jbG9zZScsICdmaWd1cmUnLCAtMSk7XG4gICAgICBmaWd1cmVDbG9zZS5ibG9jayA9IHRydWU7XG4gICAgICBmaWd1cmVDbG9zZS5sZXZlbCA9IGxldmVsO1xuXG4gICAgICBpZiAoIWlzRW1wdHkob3B0aW9ucy5jbGFzc05hbWVDb250YWluZXIpKSB7XG4gICAgICAgIGZpZ3VyZU9wZW4uYXR0clNldCgnY2xhc3MnLCBvcHRpb25zLmNsYXNzTmFtZUNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGluc2VydEF0KHRva2VucywgW2ZpZ3VyZUNsb3NlXSwgZW5kICsgNCk7XG4gICAgICBpbnNlcnRBdCh0b2tlbnMsIFtmaWd1cmVPcGVuXSwgc3RhcnQpO1xuXG4gICAgICAvLyBTa2lwIHRoZSBnZW5lcmF0ZWQgYmxvY2sgcXVvdGUgdG9rZW5zIGluIHRoZSBzdHJlYW0uXG4gICAgICBpID0gZW5kICsgNTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsZW5ndGggb2YgdGhlIHRva2VuIHN0cmVhbS5cbiAgICAgIGwgPSBsICsgNDtcbiAgICB9XG4gIH1cblxuICBtZC5jb3JlLnJ1bGVyLmFmdGVyKCdibG9jaycsICdhdHRyaWJ1dGlvbicsIHJ1bGUpO1xufTtcbiJdfQ=="}