{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js"],"names":["f","exports","module","define","amd","window","global","self","this","markdownitAttribution","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","md","options","REGEX_URL","TokenType","assign","utils","isInteger","value","isFinite","Math","floor","isEmpty","str","trim","insertAt","array","items","position","l","splice","remove","from","to","amount","matches","obj","props","prop","Object","prototype","hasOwnProperty","findToken","tokens","findMarker","marker","needle","slice","startsWith","indexOf","findAttribution","level","token","content","type","classNameContainer","classNameAttribution","removeMarker","core","ruler","after","state","start","end","j","source","index","replace","attribution","blockquoteOpen","url","match","shift","attrSet","captionOpen","Token","block","caption","children","captionClose","figureOpen","figureClose"],"mappings":"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","file":"markdown-it-attribution.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = function attributionPlugin (md, options) {\n  /**\n   * A regular expression matching common URL patterns.\n   *\n   * @see {@link https://mathiasbynens.be/demo/url-regex}\n   *\n   * @type {RegExp}\n   */\n  var REGEX_URL = /https?:\\/\\/[^\\s/$.?#()].[^\\s()]*/i;\n\n  /**\n   * An enumeration of token types.\n   *\n   * @type {Object<string,string>}\n   */\n  var TokenType = {\n    BLOCKQUOTE_OPEN: 'blockquote_open',\n    BLOCKQUOTE_CLOSE: 'blockquote_close'\n  };\n\n  /**\n   * Default options of the parser plugin.\n   *\n   * @type {Object}\n   */\n  var Defaults = {\n    classNameContainer: 'c-blockquote',\n    classNameAttribution: 'c-blockquote__attribution',\n    marker: 'â€”', // EM dash\n    removeMarker: true\n  };\n\n  /**\n   * Copy the values of all enumerable own properties from a source object to a\n   * target object.\n   *\n   * @type {Function}\n   */\n  var assign = md.utils.assign;\n\n  /**\n   * Prepare the plugin options and merge user options with the defauls.\n   *\n   * @type {Object}\n   */\n  options = assign({}, Defaults, options);\n\n  /**\n   * Determine whether the given value is an integer.\n   *\n   * @param {*} value The value to inspect.\n   * @return {Boolean}\n   */\n  function isInteger (value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n  }\n\n  /**\n   * Determine whether a given string is empty.\n   *\n   * @param {string} str The string to inspect.\n   * @return {Boolean}\n   */\n  function isEmpty (str) {\n    return !str || (str.length === 0) || (str.trim().length === 0);\n  }\n\n  /**\n   * Determine whether the given property exists.\n   *\n   * @param {Object} obj The object to inspect.\n   * @param {string} prop The property to test for.\n   * @return {Boolean}\n   */\n  function has (obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  /**\n   * Extract an url from the given string.\n   *\n   * @param {string} str The string to extract an url from.\n   * @return {string}\n   */\n  function extractUrl (str) {\n    var matches = str.match(REGEX_URL);\n    return matches !== null\n      ? matches.shift()\n      : null;\n  }\n\n  /**\n   * Determines whether a string begins with the characters of a another string.\n   *\n   * @param {string} str The string to inspect.\n   * @param {string} needle The string to search for.\n   * @return {Boolean}\n   */\n  function startsWith (str, needle) {\n    return str.slice(0, needle.length) === needle;\n  }\n\n  /**\n   * Remove whitespace from the beginning of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimStart (str) {\n    return str.replace(/^\\s+/, '');\n  }\n\n  /**\n   * Remove whitespace from the end of a string.\n   *\n   * @param {string} str The string to trim.\n   * @return {string}\n   */\n  function trimEnd (str) {\n    return str.replace(/\\s+$/, '');\n  }\n\n  /**\n   * Insert multiple items at the given index position.\n   *\n   * @param {Array} array The array to add items to.\n   * @param {Object[]} items One or multiple items to add.\n   * @param {Number} position The index position at which to add the items.\n   */\n  function insertAt (array, items, position) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      array.splice(position + i, 0, items[i]);\n    }\n  }\n\n  /**\n   * Remove all items between the given indices.\n   *\n   * @param {Array} array The array to remove items from.\n   * @param {Number} [from=0] The index to start from.\n   * @param {Number} [to=array.length-1] The index at which to stop deletion.\n   * @return {Number}\n   */\n  function remove (array, from, to) {\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : array.length - 1;\n\n    var amount = to - from;\n    var items = array.splice(from, amount);\n\n    return items.length;\n  }\n\n  /**\n   * Determine whether the given object has equal property values.\n   *\n   * @param {Object} obj The object to inspect.\n   * @param {Object} props The collection of property values to test.\n   * @return {Boolean}\n   */\n  function matches (obj, props) {\n    for (var prop in props) {\n      if (has(props, prop) && (props[prop] !== obj[prop])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Find the index of the first token that has equal property values.\n   *\n   * @param {MarkdownIt.Token[]} tokens A token stream to search within.\n   * @param {Object<string,*>} props A collection of key<->value pairs to match against.\n   * @param {Number} [position=0] The start index to start searching from.\n   * @return {Number}\n   */\n  function findToken (tokens, props, position) {\n    position = isInteger(position) ? position : 0;\n\n    for (var i = position, l = tokens.length; i < l; i++) {\n      if (matches(tokens[i], props)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Find the index position of a given marker in a string.\n   *\n   * NOTE: An attribution marker either has to be the first character of a\n   * string or it has to be immediately following a soft break/line break.\n   *\n   * @param {string} str The string to search within.\n   * @param {string} marker The marker to search for.\n   * @return {Number}\n   */\n  function findMarker (str, marker) {\n    // Return early if the paragraph starts with the marker.\n    if (startsWith(str, marker)) {\n      return 0;\n    }\n\n    // Search for the marker following a soft break.\n    var length = marker.length;\n    var position = str.indexOf('\\n' + marker, length + 1);\n\n    return (position > length) ? position + 1 : -1;\n  }\n\n  /**\n   * Find a attribution line within the given range.\n   *\n   * @param {MarkdownIt.Token[]} tokens The token stream to search.\n   * @param {string} marker The character code of the attribution marker.\n   * @param {Number} [level=0] The level of the block quote.\n   * @param {Number} [from=0] The index position to start searching from.\n   * @param {Number} [to=tokens.length-1] The upper boundary to stop searching.\n   * @return {Number}\n   */\n  function findAttribution (tokens, marker, level, from, to) {\n    level = isInteger(level) ? level : 0;\n    from = isInteger(from) ? from : 0;\n    to = isInteger(to) ? to : tokens.length;\n\n    for (var i = from; i < to; i++) {\n      var token = tokens[i];\n      var content = token.content;\n\n      if ((token.type !== 'inline') || (token.level !== level + 2) || (content.length === 0)) {\n        continue;\n      }\n\n      var position = findMarker(content, marker);\n\n      if (position !== -1) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Attribution Rule\n   *\n   * Improve the generated HTML markup for block quotes with proper attribution\n   * syntax.\n   *\n   * @param {MarkdownIt.StateCore} state The current state of the parser.\n   * @return {void}\n   */\n  function rule (state) {\n    var tokens = state.tokens;\n\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      // Find the opening tag of the next blockquote.\n      var start = findToken(tokens, { type: TokenType.BLOCKQUOTE_OPEN }, i);\n\n      if (start === -1) {\n        continue;\n      }\n\n      // Find the closing tag of the current block quote.\n      var level = tokens[start].level;\n      var end = findToken(tokens, { type: TokenType.BLOCKQUOTE_CLOSE, level: level }, start + 1);\n\n      /* istanbul ignore if */\n      if (end === -1) {\n        continue;\n      }\n\n      // Find the attribution line of the current block quote.\n      var position = findAttribution(tokens, options.marker, level, start + 1, end);\n\n      if (position === -1) {\n        continue;\n      }\n\n      // Increase the level of each block quote token as it will be wrapped in a\n      // container element.\n      for (var j = start; j <= end; j++) {\n        tokens[j].level++;\n      }\n\n      // Remove the attribution line from the rest of the paragraph.\n      var token = tokens[position];\n      var source = token.content;\n      var index = findMarker(source, options.marker);\n\n      var content = (index > 0) ? trimEnd(source.slice(0, index)) : null;\n      var attribution = (index > 0) ? source.slice(index) : source;\n\n      token.content = content;\n\n      // Remove the paragraph tokens from the stream, if no content is left.\n      if (isEmpty(content)) {\n        end -= remove(tokens, position - 1, position + 2);\n      }\n\n      // Use any url found in the attribution line as the cite attribute.\n      var blockquoteOpen = tokens[start];\n      var url = extractUrl(attribution);\n\n      if (!isEmpty(url)) {\n        blockquoteOpen.attrSet('cite', url);\n      }\n\n      // Create new tokens for the attribution line.\n      var captionOpen = new state.Token('blockquote_attribution_open', 'figcaption', 1);\n      captionOpen.block = true;\n      captionOpen.level = level + 1;\n\n      var caption = new state.Token('inline', '', 0);\n      caption.children = [];\n      caption.level = level + 2;\n      caption.content = options.removeMarker\n        ? trimStart(attribution.slice(options.marker.length))\n        : attribution;\n\n      var captionClose = new state.Token('blockquote_attribution_close', 'figcaption', -1);\n      captionClose.block = true;\n      captionClose.level = level + 1;\n\n      if (!isEmpty(options.classNameAttribution)) {\n        captionOpen.attrSet('class', options.classNameAttribution);\n      }\n\n      insertAt(tokens, [captionOpen, caption, captionClose], end + 1);\n\n      // Wrap block quote and attribution in a figure element.\n      var figureOpen = new state.Token('blockquote_container_open', 'figure', 1);\n      figureOpen.block = true;\n      figureOpen.level = level;\n\n      var figureClose = new state.Token('blockquote_container_close', 'figure', -1);\n      figureClose.block = true;\n      figureClose.level = level;\n\n      if (!isEmpty(options.classNameContainer)) {\n        figureOpen.attrSet('class', options.classNameContainer);\n      }\n\n      insertAt(tokens, [figureClose], end + 4);\n      insertAt(tokens, [figureOpen], start);\n\n      // Skip the generated block quote tokens in the stream.\n      i = end + 5;\n\n      // Update the length of the token stream.\n      l = l + 4;\n    }\n  }\n\n  md.core.ruler.after('block', 'attribution', rule);\n};\n"]}